<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>李宜衡的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-09-01T01:52:59.556Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>李宜衡</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>配置idea自动生成javadoc</title>
    <link href="http://yoursite.com/2018/09/01/%E9%85%8D%E7%BD%AEidea%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90javadoc/"/>
    <id>http://yoursite.com/2018/09/01/配置idea自动生成javadoc/</id>
    <published>2018-09-01T01:16:17.000Z</published>
    <updated>2018-09-01T01:52:59.556Z</updated>
    
    <content type="html"><![CDATA[<p>随着学习的深入，开发也应该走向规范化，注释就是很重要的一个方面，一个规范的注释应该让别人能一眼知道，他需要传什么才能用这个方法，用了这个方法他能得到什么，而且就如潘老师所说，还应该编码者的名字，如果这方法有问题可以迅速的找到他。</p><p><img src="\images\pasted-26.png" alt="upload successful"></p><p>但是每次都慢慢编写注释无疑比较麻烦，有的人就不太愿意写，还好idea给我们提供了javedoc模板，模板创建完成以后只需几个快键键就可以创建一个规范的注释。</p><h3 id="创建模板"><a href="#创建模板" class="headerlink" title="创建模板"></a>创建模板</h3><h5 id="首先是类的注释"><a href="#首先是类的注释" class="headerlink" title="首先是类的注释"></a>首先是类的注释</h5><p><img src="\images\pasted-27.png" alt="upload successful"></p><p>打开设置，进入【 Editor | File and Code Templates】<br>选择【includes】选择file header,在右侧填入如下代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/** </span><br><span class="line">* </span><br><span class="line">* @author yourname </span><br><span class="line">* @date $&#123;DATE&#125; $&#123;TIME&#125; </span><br><span class="line">*/</span><br></pre></td></tr></table></figure></p><p>当然你可以在里面添加任何你想添加的注释的东西，其中有$标志的代表动态获取，效果如下</p><p><img src="\images\pasted-28.png" alt="upload successful"></p><p>类的注释会在类完成时，自动添加</p><h5 id="方法的注释"><a href="#方法的注释" class="headerlink" title="方法的注释"></a>方法的注释</h5><p>这个稍微麻烦一些，首先需要新建一个group<br><img src="\images\pasted-29.png" alt="upload successful"></p><p>然后选中新建的group，还是那个地方选择live template</p><p><img src="\images\pasted-30.png" alt="upload successful"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">**</span><br><span class="line"> *</span><br><span class="line"> * @param: $params$</span><br><span class="line"> * @return $returns$</span><br><span class="line"> * @author liyiheng</span><br><span class="line"> * @date $date$ $time$ </span><br><span class="line"> */</span><br></pre></td></tr></table></figure></p><p>之所以没有斜杠，是测试以后比较好。<br>最后一步，点击edit variables配置Expression</p><p><img src="\images\pasted-31.png" alt="upload successful"></p><p>大功告成</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;随着学习的深入，开发也应该走向规范化，注释就是很重要的一个方面，一个规范的注释应该让别人能一眼知道，他需要传什么才能用这个方法，用了这个方法他能得到什么，而且就如潘老师所说，还应该编码者的名字，如果这方法有问题可以迅速的找到他。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;\imag
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>单元测试</title>
    <link href="http://yoursite.com/2018/08/29/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    <id>http://yoursite.com/2018/08/29/单元测试/</id>
    <published>2018-08-29T09:41:43.000Z</published>
    <updated>2018-08-29T11:39:34.776Z</updated>
    
    <content type="html"><![CDATA[<p>看了老师的教程，开始的时候对为什么使用单元测试感到很困惑，随着教程的学习和查阅资料渐渐的对单元测试有了了解。</p><p>教程中用到的单元测试框架是junit4， spring中已经集成了，不用单独配置，单元测试有什么用？刚开始学时可能体会不到，因为我们在学习sthinkphp时已经习惯了写完一个完整的功能后再添加数据去测试功能，而单元测试是写完一个小功能后就测试一下，虽然需要多写一部分代码<br>但从长期来看，可以提高代码质量，减少维护成本，不用在任务完成以后一大推代码中找bug</p><h3 id="单元测试中用到的注解"><a href="#单元测试中用到的注解" class="headerlink" title="单元测试中用到的注解"></a>单元测试中用到的注解</h3><p><img src="\images\pasted-23.png" alt="upload successful"></p><p>红框中的两个是测试必须的，他表示了这是一个测试类<br>这两个注解应该放在类的上面<br>红框下的这个注解是表示事务的，这里不重点讨论。  </p><p><img src="\images\pasted-24.png" alt="upload successful"></p><p>每一个测试的方法上都需要一个@Test注解，表示这是一个测试</p><h3 id="什么时候测"><a href="#什么时候测" class="headerlink" title="什么时候测"></a>什么时候测</h3><p>单元测试需要在两个阶段测试</p><p>（1）一是在具体实现代码之前，这是测试驱动开发（TDD）所提倡的；</p><p>（2）二是功能代码完成后。</p><h3 id="mock"><a href="#mock" class="headerlink" title="mock"></a>mock</h3><p>开始看到mock这个东西的时候，感觉很迷惑，不太明白这个是干什么的，所以就找了篇博客看了看  </p><p>mock测试就是在测试过程中，对于某些不容易构造或者不容易获取的对象，用一个虚拟的对象来创建以便测试的测试方法。</p><p><img src="\images\pasted-25.png" alt="upload successful"></p><p>mock的使用就如上图所示</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对于单元测试，开始接触时，我们肯定会感到很迷茫，不知道从何开始，幸好，潘老师给我们写好了实例代码，照着例子一步一步熟悉，渐渐就会了，还有一定不要怕麻烦，现在多的几行代码，可能会节省改bug一天的时间。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;看了老师的教程，开始的时候对为什么使用单元测试感到很困惑，随着教程的学习和查阅资料渐渐的对单元测试有了了解。&lt;/p&gt;
&lt;p&gt;教程中用到的单元测试框架是junit4， spring中已经集成了，不用单独配置，单元测试有什么用？刚开始学时可能体会不到，因为我们在学习sthink
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>php中 isset(), empty(), is_null()</title>
    <link href="http://yoursite.com/2018/08/24/php%E4%B8%AD-isset-empty-is-null/"/>
    <id>http://yoursite.com/2018/08/24/php中-isset-empty-is-null/</id>
    <published>2018-08-24T06:43:52.000Z</published>
    <updated>2018-08-29T09:14:40.297Z</updated>
    
    <content type="html"><![CDATA[<p>做项目时发现一个地方用empty（）判断不好使，在陈杰的提醒下知道了还有个is_null（），然后又有个isset（）对这几个方法感觉很迷糊，就上网找了找博客看看，并且总结一下。</p><h3 id="isset"><a href="#isset" class="headerlink" title="isset()"></a>isset()</h3><p>isset()是判断一个变量设定了没如果设定了并且不为null就返回true。<br>当为null或未设定时就返回false。</p><h3 id="is-null"><a href="#is-null" class="headerlink" title="is_null()"></a>is_null()</h3><p> is_null会在三种情况返回true<br> 1.被赋值为null<br> 2.未赋值<br> 3.未定义   </p><p> 和isset在某种意义上可以说是反义词</p><h3 id="empty"><a href="#empty" class="headerlink" title="empty()"></a>empty()</h3><p>  “”、0、”0”、NULL、FALSE、array()以及只是单纯定义一个变量$var，这些情况empty()都会返回ture  </p><p> 如果还是不太清楚，这里贴一篇介绍的和清楚的博客</p><p><a href="https://blog.csdn.net/jiaobuchong/article/details/41807011" target="_blank" rel="noopener">https://blog.csdn.net/jiaobuchong/article/details/41807011</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;做项目时发现一个地方用empty（）判断不好使，在陈杰的提醒下知道了还有个is_null（），然后又有个isset（）对这几个方法感觉很迷糊，就上网找了找博客看看，并且总结一下。&lt;/p&gt;
&lt;h3 id=&quot;isset&quot;&gt;&lt;a href=&quot;#isset&quot; class=&quot;head
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>级联表单的学习</title>
    <link href="http://yoursite.com/2018/08/23/%E7%BA%A7%E8%81%94%E8%A1%A8%E5%8D%95%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2018/08/23/级联表单的学习/</id>
    <published>2018-08-23T06:21:35.000Z</published>
    <updated>2018-08-23T07:32:25.991Z</updated>
    
    <content type="html"><![CDATA[<p>因为项目需要学院、专业、年级、班级联系起来，所以用了级联的下拉菜单。做这个遇到了不少的困难。甚至开始的时候都不知道这个叫什么，搜索都不知道用什么关键词。后来还是从学长们哪知道这个叫级联，然后张喜硕学长以前也写过，于是在他的代码的基础上终于完成了这个功能。</p><p><img src="\images\2018-08-23_143011.png" alt="1"></p><h3 id="如何实现的"><a href="#如何实现的" class="headerlink" title="如何实现的"></a>如何实现的</h3><p>实现这个主要依靠了html标签的onchange属性来触发js的函数。</p><p><img src="\images\pasted-16.png" alt="upload successful"></p><p>这一段代码好像是后面用来设置默认选中的</p><p><img src="\images\pasted-17.png" alt="upload successful"></p><p>当点击目标并选中时就会触发getMajor方法</p><p><img src="\images\pasted-19.png" alt="upload successful"><br>先通过id取得级联的两个目标的节点<br>然后找到被选中目标的value中的值<br>然后通过ajax访问后台的方法<br>取得目标对象<br>然后把目标对象填充到下一个节点的option中去并设置选中状态</p><p><img src="\images\pasted-20.png" alt="upload successful"><br>然后创建一个隐藏的input按钮，以便和from表单配合  </p><p>下面是另外几个用到的函数</p><p><img src="\images\pasted-21.png" alt="upload successful"></p><p><img src="\images\pasted-22.png" alt="upload successful"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>级联的学习运用可以说是收获巨大的，从开始的完全不知如何下手，到面对js的茫然，以及慢慢实现自己想要的功能的成就感，同时学长们的帮助也是巨大的，要是没有学长们提供的帮助，这种功能自己不知道得琢磨到啥时候，毕竟连叫啥名字都不知道。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;因为项目需要学院、专业、年级、班级联系起来，所以用了级联的下拉菜单。做这个遇到了不少的困难。甚至开始的时候都不知道这个叫什么，搜索都不知道用什么关键词。后来还是从学长们哪知道这个叫级联，然后张喜硕学长以前也写过，于是在他的代码的基础上终于完成了这个功能。&lt;/p&gt;
&lt;p&gt;&lt;i
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>记一次失败的双系统安装</title>
    <link href="http://yoursite.com/2018/08/14/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%A4%B1%E8%B4%A5%E7%9A%84%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/"/>
    <id>http://yoursite.com/2018/08/14/记一次失败的双系统安装/</id>
    <published>2018-08-14T02:39:05.000Z</published>
    <updated>2018-08-14T04:06:56.087Z</updated>
    
    <content type="html"><![CDATA[<p>这两天一直在尝试装win10+unbunt的双系统，两天耗下来可谓一路艰辛，虽然最后还是放弃了，但在解决各种问题中，也学到了不少。</p><h3 id="一-装ubuntu中遇到的问题"><a href="#一-装ubuntu中遇到的问题" class="headerlink" title="一.装ubuntu中遇到的问题"></a>一.装ubuntu中遇到的问题</h3><p>装系统的步骤网上一找一大堆，就不说了，就直接谈谈遇到的问题和解决办法吧。</p><h4 id="1-安装时卡在logo界面"><a href="#1-安装时卡在logo界面" class="headerlink" title="1.安装时卡在logo界面"></a>1.安装时卡在logo界面</h4><p>这是因为显卡驱动的原因，ubuntu自带的开源的N卡驱动不太好使，理论上是要安装一个新的的，但是安装安装过程会出现各种问题，我就是因此放弃了双系统。</p><p>解决办法：进入U盘启动之后，光标选定”install Ubuntu”之后，按“e”进入编辑页面（不是enter键确定），然后找到quiet splash—，空格添<br>加 nomodeset,按F10保存，即可正常进入。</p><p>网上有的说这只是临时方法，安装完成以后还会遇到，不过我就只在安装过程有这问题，理论上的永久解决办法：解决方法：修改grub.cfg文件，在该文件里面完成添加$vt_handoff acpi_osi=linux nomodeset的操作，并保存。</p><p>安装过程的问题基本就这一个。</p><h4 id="2-安装显卡驱动"><a href="#2-安装显卡驱动" class="headerlink" title="2.安装显卡驱动"></a>2.安装显卡驱动</h4><p>这对我是一个大问题，最后也没成功解决，完全按照教程，最后却无法进入登录界面，卡在了加载界面，重装了好多次，重启了无数次。</p><p>安装方法主要有三种<br>不管那种方式都得先禁用原来的驱动，否则会出现循环登录，或进不去系统的情况，两种情况我都遇到了，希望大家不要作死了。<br>禁用方法如下：<br>$sudo ls -lh /etc/modprobe.d/blacklist.conf</p><p>修改属性<br>$sudo chmod 666 /etc/modprobe.d/blacklist.conf</p><p>用gedit打开<br>$sudo gedit /etc/modpro<br>be.d/blacklist.conf</p><p>在该文件后添加以下几行：</p><p>blacklist vga16fb<br>blacklist nouveau<br>blacklist rivafb<br>blacklist rivatv<br>blacklist nvidiafb</p><p>sudo update-initramfs -u<br>（1）PPA源<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:xorg-edgers/ppa #添加ppa源</span><br><span class="line">sudo add-apt-repository ppa:graphics-drivers/ppa #添加ppa源</span><br><span class="line">sudo apt-get update #更新apt-get</span><br><span class="line">要知道需要安装哪个类型的显卡驱动，可以使用如下指令查看 </span><br><span class="line">sudo add-apt-repository ppa:graphics-drivers</span><br><span class="line"></span><br><span class="line">sudo apt-get remove --purge nvidia*//卸载原有驱动</span><br><span class="line">sudo apt-get install nvidia-387此处根据上面找到的型号下载</span><br><span class="line">sudo apt-get install mesa-common-dev</span><br><span class="line">sudo apt-get install freeglut3-dev</span><br></pre></td></tr></table></figure></p><p>（2）.runfile安装<br>找到适合的正确的驱动，去nvidia驱动官网下载</p><p>卸载掉原有驱动</p><p>sudo apt-get remove –purge nvidia</p><p>禁用X服务<br>执行：</p><p>sudo /etc/init.d/lightdm stop</p><p>安装驱动<br>进入命令行界面<br>Ctrl-Alt+F1</p><p>给驱动run文件赋予执行权限<br>sudo chmod a+x NVIDIA-Linux-x86_64-375.20.run</p><p>安装(注意 参数)<br>sudo ./NVIDIA-Linux-x86_64-375.20.run –no-opengl-files</p><p>–no-opengl-files </p><p>只安装驱动文件，不安装OpenGL文件。这个参数最重要</p><p>–no-x-check </p><p>安装驱动时不检查X服务</p><p>–no-nouveau-check</p><p>安装驱动时不检查nouveau </p><p>后面两个参数可不加。</p><p>（3）用软件和更新安装</p><p><img src="\images\pasted-14.png" alt="upload successful"><br>这种办法可以可以说是最简单的了，但我也失败了</p><p>三种方法里我用过两种，runfile方法由于不太熟悉ubuntu的命令，看不太懂就没尝试，后来在虚拟机里面学习团队教程以后才明白了。</p><h3 id="二-总结"><a href="#二-总结" class="headerlink" title="二.总结"></a>二.总结</h3><p>这次装系统对ubuntu的命令行有了一定的了解，并且装了各种系统，中途甚至搞坏了两次windows，让我对系统的引导有了一定的了解，还有系统的分区等等，总得来说，这两天不亏。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这两天一直在尝试装win10+unbunt的双系统，两天耗下来可谓一路艰辛，虽然最后还是放弃了，但在解决各种问题中，也学到了不少。&lt;/p&gt;
&lt;h3 id=&quot;一-装ubuntu中遇到的问题&quot;&gt;&lt;a href=&quot;#一-装ubuntu中遇到的问题&quot; class=&quot;headerli
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>git使用总结</title>
    <link href="http://yoursite.com/2018/08/10/git%E4%BD%BF%E7%94%A8%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/08/10/git使用学习总结/</id>
    <published>2018-08-10T13:34:45.000Z</published>
    <updated>2018-08-11T02:56:19.296Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-git是什么"><a href="#1-git是什么" class="headerlink" title="1.git是什么"></a>1.git是什么</h3><p>git是一个版本控制工具，目前来说，git给我最大的印象就是团队协作开发十分方便，大家在自己的电脑写程序，提交时会自动的显示出不同，便于管理者查看是否要将其合并到master上。<br>当然git还有一个重要的功能：版本控制，由于暂时没有怎么使用过在此不多介绍。</p><h3 id="2-git常用命令"><a href="#2-git常用命令" class="headerlink" title="2.git常用命令"></a>2.git常用命令</h3><p>git有两个客户端：</p><p>一个是git的命令行的客户端</p><p><img src="\images\pasted-15.png" alt="upload successful"></p><p>一个是github的桌面端</p><p><img src="\images\pasted-18.png" alt="upload successful"></p><p>先说的是git的命令行</p><p>git有许多十分方便强大的命令：</p><h5 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h5><pre><code>在本地新建一个 repo, 进入一个项目目录, 执行 git init, 会初始化一个 repo, 并在当前文件夹下创建一个. git 文件夹.有了.git文件夹才能和github联系起来。</code></pre><h5 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h5><pre><code>获取一个 url 对应的远程 Git repo, 创建一个 local copy.一般的格式是 git clone [url].clone 下来的 repo 会以 url 最后一个斜线后面的名称命名, 创建一个文件夹, 如果想要指定特定的名称, 可以 git clone [url] newname 指定.</code></pre><h5 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h5><pre><code>git status命令用于显示工作目录和暂存区的状态。使用此命令能看到那些修改被暂存到了, 哪些没有, 哪些文件没有被 Git tracked 到。git status不显示已经commit到项目历史中去的信息。看项目历史的信息要使用git log.</code></pre><h5 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h5><pre><code>git checkout (branchname)   切换到一个分支.   git checkout -b (branchname): 创建并切换到新的分支.   这个命令是将 git branch newbranch 和 git checkout newbranch 合在一起的结果.   checkout 还有另一个作用: 替换本地改动: git checkout --&lt;filename&gt; 此命令会使用 HEAD 中的最新内容替换掉你的工作目录中的文件. 已添加到暂存区的改动以及新文件都不会受到影响. 注意: git checkout filename 会删除该文件中所有没有暂存和提交的改动, 这个操作是不可逆的.</code></pre><p> 当然git的命令远远不止这些，这些只是我用过的或者见过他人使用的。</p><h3 id="3-github客户端的使用流程"><a href="#3-github客户端的使用流程" class="headerlink" title="3.github客户端的使用流程"></a>3.github客户端的使用流程</h3><p>使用git命令行当然可以完成关于git的所有操作，但就提交代码来说，github的桌面客户端无疑要方便许多</p><p><img src="\images\pasted-12.png" alt="upload successful"></p><p>使用流程就是这样</p><h4 id="1-gt-2-gt-3-gt-4-gt-creat-pull-request"><a href="#1-gt-2-gt-3-gt-4-gt-creat-pull-request" class="headerlink" title="1-&gt;2-&gt;3-&gt;4-&gt;creat pull request"></a>1-&gt;2-&gt;3-&gt;4-&gt;creat pull request</h4><p>在1处写下一个总结性的标题<br>然后在2处关联issue，同时在关联issue时可以用关键字让这个issue自动关闭，当这个puull request被合并时，issue就会自动关闭</p><h5 id="Closes-123”-or-“Closes-123"><a href="#Closes-123”-or-“Closes-123" class="headerlink" title="Closes #123” or “Closes: #123"></a>Closes #123” or “Closes: #123</h5><p>就像这样，这样的关键字还有很多：</p><ul><li>close</li><li>closes</li><li>closed</li><li>fix</li><li>fixes</li><li>fixed</li><li>resolve</li><li>resolves</li><li>resolved</li></ul><p>然后还可以用关键字关闭不同创库的issue用法如下：</p><h5 id="Closes-example-user-example-repo-76"><a href="#Closes-example-user-example-repo-76" class="headerlink" title="Closes example_user/example_repo#76"></a>Closes example_user/example_repo#76</h5><p>当该pull request被同意时，就会关闭相应的分支，</p><p>同样可以一次关闭多个issue：</p><h5 id="This-closes-34-closes-23-and-closes-example-user-example-repo-42"><a href="#This-closes-34-closes-23-and-closes-example-user-example-repo-42" class="headerlink" title="This closes #34, closes #23, and closes example_user/example_repo#42"></a>This closes #34, closes #23, and closes example_user/example_repo#42</h5><h3 id="4-结束"><a href="#4-结束" class="headerlink" title="4.结束"></a>4.结束</h3><p>开始使用git时犯了很多错误，但随着使用渐渐有了头绪，<br>git和编程语言一样都是一个工具，而工具不是光靠了解理论就行的，对于工具我们只有靠多加使用才能熟能生巧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-git是什么&quot;&gt;&lt;a href=&quot;#1-git是什么&quot; class=&quot;headerlink&quot; title=&quot;1.git是什么&quot;&gt;&lt;/a&gt;1.git是什么&lt;/h3&gt;&lt;p&gt;git是一个版本控制工具，目前来说，git给我最大的印象就是团队协作开发十分方便，大家在自己
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>php  curl学习总结</title>
    <link href="http://yoursite.com/2018/06/14/php-curl%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/06/14/php-curl学习总结/</id>
    <published>2018-06-14T10:03:02.000Z</published>
    <updated>2018-06-15T07:45:47.983Z</updated>
    
    <content type="html"><![CDATA[<p>由于项目的需要学习了PHP的curl，，虽然本项目的相关部分由黄庭祥完成，但感觉这个很重要，并且很有意思所以也做个总结吧。</p><h3 id="curl是什么"><a href="#curl是什么" class="headerlink" title="curl是什么"></a>curl是什么</h3><p>cURL 是一个利用 URL 语法规定来传输文件和数据的工具，支持很多协议，如 HTTP、FTP、TELNET 等。最爽的是，PHP 也支持 cURL 库。使用 PHP 的 cURL 库可以简单和有效地去抓网页。你只需要运行一个脚本，然后分析一下你所抓取的网页，然后就可以以程序的方式得到你想要的数据了。无论是你想从从一个链接上取部分数据，或是取一个 XML 文件并把其导入数据库，那怕就是简单的获取网页内容，cURL 是一个功能强大的 PHP 库。  </p><p>可以说curl是相当强大了（c和c++中都没学到这么有意思的东西）</p><h3 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">curl的使用还是比较简单的，基本上就分为四步</span><br><span class="line"></span><br><span class="line"> 初始化</span><br><span class="line">$ch = curl_init()//创建了一个 curl 会话资源，成功返回一个句柄； </span><br><span class="line">设置各种属性</span><br><span class="line">curl_setopt($ch, CURLOPT_URL, &quot;baidu.com&quot;)//设置 URL，不用说；</span><br><span class="line">curl_setopt($ch, CURLOPT_RETURNTRANSFER, 0)//这是设置是否将响应结果存入变量，1 是存入，0 是直接 echo 出；</span><br><span class="line"></span><br><span class="line">执行</span><br><span class="line">$output = curl_exec($ch)//执行，然后将响应结果存入$output变量，供下面 echo；</span><br><span class="line"></span><br><span class="line">curl_close($ch)关闭这个 curl 会话资源</span><br></pre></td></tr></table></figure><p>这样就可以抓取到该网站的代码了，这只是其中最简单的用法，curl还可以完成很多高端操作<br>比如</p><h6 id="curl也可以批量处理"><a href="#curl也可以批量处理" class="headerlink" title="curl也可以批量处理"></a>curl也可以批量处理</h6><h6 id="GET-和-POST-请求以及-HTTPS-协议处理"><a href="#GET-和-POST-请求以及-HTTPS-协议处理" class="headerlink" title="GET 和 POST 请求以及 HTTPS 协议处理"></a>GET 和 POST 请求以及 HTTPS 协议处理</h6><h6 id="上传和下载文件"><a href="#上传和下载文件" class="headerlink" title="上传和下载文件"></a>上传和下载文件</h6><h6 id="HTTP-认证"><a href="#HTTP-认证" class="headerlink" title="HTTP 认证"></a>HTTP 认证</h6><h6 id="利用-cookie-模拟登陆"><a href="#利用-cookie-模拟登陆" class="headerlink" title="利用 cookie 模拟登陆"></a>利用 cookie 模拟登陆</h6><p>当然要实现这些功能就需要用到curl中的其他函数了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">二、CURL 函数库。</span><br><span class="line"></span><br><span class="line">curl_close — 关闭一个 curl 会话</span><br><span class="line">curl_copy_handle — 拷贝一个 curl 连接资源的所有内容和参数</span><br><span class="line">curl_errno — 返回一个包含当前会话错误信息的数字编号</span><br><span class="line">curl_error — 返回一个包含当前会话错误信息的字符串</span><br><span class="line">curl_exec — 执行一个 curl 会话</span><br><span class="line">curl_getinfo — 获取一个 curl 连接资源句柄的信息</span><br><span class="line">curl_init — 初始化一个 curl 会话</span><br><span class="line">curl_multi_add_handle — 向 curl 批处理会话中添加单独的 curl 句柄资源</span><br><span class="line">curl_multi_close — 关闭一个批处理句柄资源</span><br><span class="line">curl_multi_exec — 解析一个 curl 批处理句柄</span><br><span class="line">curl_multi_getcontent — 返回获取的输出的文本流</span><br><span class="line">curl_multi_info_read — 获取当前解析的 curl 的相关传输信息</span><br><span class="line">curl_multi_init — 初始化一个 curl 批处理句柄资源</span><br><span class="line">curl_multi_remove_handle — 移除 curl 批处理句柄资源中的某个句柄资源</span><br><span class="line">curl_multi_select — Get all the sockets associated with the cURL extension, which can then be “selected”</span><br><span class="line">curl_setopt_array — 以数组的形式为一个 curl 设置会话参数</span><br><span class="line">curl_setopt — 为一个 curl 设置会话参数</span><br><span class="line">curl_version — 获取 curl 相关的版本信息</span><br><span class="line"></span><br><span class="line">curl_init() 函数的作用初始化一个 curl 会话，curl_init() 函数唯一的一个参数是可选的，表示一个 url 地址。</span><br><span class="line">curl_exec() 函数的作用是执行一个 curl 会话，唯一的参数是 curl_init() 函数返回的句柄。</span><br><span class="line">curl_close() 函数的作用是关闭一个 curl 会话，唯一的参数是 curl_init()</span><br></pre></td></tr></table></figure><h3 id="两个问题"><a href="#两个问题" class="headerlink" title="两个问题"></a>两个问题</h3><p>这是从网上看到的两个curl容易遇到的问题，虽然没有遇到，暂且记录在此  ：<br>cURL 提示 can’t resovle host<br>cURL 提示无法解析域名，然后就没有更多的信息了。但经过调查，发现域名是正确的，DNS 服务器也没有问题，可 cURL 仍锲而不舍地稳定地告诉你域名无法解析。</p><p>真实原因是服务器上启用了 IPv6，而 IPv6 网络无法连通。在启用了 IPv6 的情况下，cURL 会通过 IPv6 进行 DNS 查询，而 IPv6 网络不可用，cURL 在查询失败之后没有尝试通过 IPv4 再次解析域名，而是直接报错：域名无法解析。</p><p>这个坑里面还有一个小坑，cURL 有一个 CURLOPT_IPRESOLVE 选项，根据文档，我们可以通过这个设定让 cURL 不要通过 IPv6 去解析域名。但是，这个选项似乎有时候无法正常工作。稳妥起见，如果没有可用 IPv6 网络的话，请关闭服务器的 IPv6 支持，然后重启 PHP。</p><p>使用 cURL 后脚本迟迟无法结束<br>cURL 在进行网络请求时，如果遇到网络问题，就会一直等待下去，并无视 PHP 系统级别的超时时间设置。如果你发现你的脚本执行时间超过了设定的 PHP 执行时间限制，那就可以怀疑脚本是卡在 cURL 里面了。</p><p>举个例子来说，假设设定了 PHP 脚本超时时间为 30 秒，脚本中使用 cURL 进行了一个网络请求，在网络不稳定的情况下（比如 TCP 连接已建立，但一直没有收到服务器数据），cURL 会一直等待下去，直到默认的 cURL 超时时间后才返回。当 cURL 超时返回后，PHP 才有机会检查脚本是否已经超时。如果 cURL 设定的超时时间是 300 秒，那么这个 PHP 脚本将会在 300 秒后才会结束运行。</p><p>这种情况对于网站服务器来说是很危险的。假设服务器使用 PHP-FPM 模式运行 PHP，并设定了最大 PHP 进程数为 100. 如果某个涉及使用 cURL 进行网络请求的脚本被频繁调用，而网络不太稳定时，PHP-FPM 进程池可能就会被这些等待网络超时的 PHP 进程占满，最终导致没有空闲的 PHP 进程来处理新的请求。</p><p>对于这种情况，请对通过 CURLOPT_TIMEOUT 等选项对 cURL 设定网络操作的超时时间。</p><p>多嘴一句，就算使用 CURLOPT_TIMEOUT 设定了 cURL 的超时时间，上面所说的 PHP-FPM 进程池被占满的情况仍然可能出现。网络操作是很不可控的，最好避免在 PHP 请求中进行网络操作，应尽量把网络操作放到 PHP 请求之外异步执行。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这次做项目可以说打开了新世界的大门也不为过，总算做出了一个有实际作用的东西，而且还了解到了很多PHP的函数。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于项目的需要学习了PHP的curl，，虽然本项目的相关部分由黄庭祥完成，但感觉这个很重要，并且很有意思所以也做个总结吧。&lt;/p&gt;
&lt;h3 id=&quot;curl是什么&quot;&gt;&lt;a href=&quot;#curl是什么&quot; class=&quot;headerlink&quot; title=&quot;curl是什么&quot;&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>tp5的获取器</title>
    <link href="http://yoursite.com/2018/06/03/tp5%E7%9A%84%E8%8E%B7%E5%8F%96%E5%99%A8/"/>
    <id>http://yoursite.com/2018/06/03/tp5的获取器/</id>
    <published>2018-06-03T12:38:18.000Z</published>
    <updated>2018-06-10T12:37:53.346Z</updated>
    
    <content type="html"><![CDATA[<p>thinkphp5中有一个十分好用的方法–获取器，获取器的作用是在获取数据的字段值后自动进行处理。</p><h3 id="零-获取器的格式"><a href="#零-获取器的格式" class="headerlink" title="零.获取器的格式"></a>零.获取器的格式</h3><h5 id="getFieldNameAttr（）"><a href="#getFieldNameAttr（）" class="headerlink" title="getFieldNameAttr（）{}"></a>getFieldNameAttr（）{}</h5><p>只需在对象中定义这种方法，就可以在访问该数据是自动对其转换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public function getSexAttr($value)</span><br><span class="line">   &#123;</span><br><span class="line">       $status = array(&apos;0&apos;=&gt;&apos;男&apos;,&apos;1&apos;=&gt;&apos;女&apos;);</span><br><span class="line">       $sex = $status[$value];</span><br><span class="line">       if (isset($sex))</span><br><span class="line">       &#123;</span><br><span class="line">           return $sex;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           return $status[0];</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>比如这段代码，在访问sex数据时就会自动转换</p><p><img src="\images\pasted-11.png" alt="upload successful"></p><h3 id="一-获取器中的第二个参数"><a href="#一-获取器中的第二个参数" class="headerlink" title="一.获取器中的第二个参数"></a>一.获取器中的第二个参数</h3><p>获取器方法的第二个参数传入的是当前的所有数据数组。</p><p>我们就可以直接使用 status_text 字段的值了，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$user = User::get(1);</span><br><span class="line">echo $user-&gt;status_text; // 例如输出“正常”</span><br></pre></td></tr></table></figure></p><p>获取器只有当获取某个数据属性的时候自动触发，如果你要获取包含获取器处理<br>的全部数据属性的话，可以使用下面的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$user = User::get(1);</span><br><span class="line">// 获取全部获取器数据</span><br><span class="line">dump($user-&gt;toArray());</span><br></pre></td></tr></table></figure></p><h3 id="二-获取原始数据"><a href="#二-获取原始数据" class="headerlink" title="二.获取原始数据"></a>二.获取原始数据</h3><p>如果你定义了获取器的情况下，希望获取数据表中的原始数据，可以使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$user = User::get(1);</span><br><span class="line">// 通过获取器获取字段</span><br><span class="line">echo $user-&gt;status;</span><br><span class="line">// 获取原始字段数据</span><br><span class="line">echo $user-&gt;getData(&apos;status&apos;);</span><br><span class="line">// 获取全部原始数据</span><br><span class="line">dump($user-&gt;getData());</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;thinkphp5中有一个十分好用的方法–获取器，获取器的作用是在获取数据的字段值后自动进行处理。&lt;/p&gt;
&lt;h3 id=&quot;零-获取器的格式&quot;&gt;&lt;a href=&quot;#零-获取器的格式&quot; class=&quot;headerlink&quot; title=&quot;零.获取器的格式&quot;&gt;&lt;/a&gt;零.获取器
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>rest设计原则的总结</title>
    <link href="http://yoursite.com/2018/06/03/4/"/>
    <id>http://yoursite.com/2018/06/03/4/</id>
    <published>2018-06-03T11:45:39.000Z</published>
    <updated>2018-06-09T02:11:13.268Z</updated>
    
    <content type="html"><![CDATA[<h3 id="零-原因"><a href="#零-原因" class="headerlink" title="零.原因"></a>零.原因</h3><p>最近一直在学一个视频教程，视频中的老师介绍了一个rest原则，虽然感觉当时懂了，然后发现没多久就忘了，所以决定写这个来加深一下印象。</p><h3 id="一"><a href="#一" class="headerlink" title="一"></a>一</h3><p>   网络应用程序，分为前端和后端两个部分。当前的发展趋势，就是前端设备层出不穷（手机、平板、桌面电脑、其他专用设备……）。</p><p>因此，必须有一种统一的机制，方便不同的前端设备与后端进行通信。目前主流的标准基本上是两个rest和soap（我了解的）。</p><h5 id="SOAP"><a href="#SOAP" class="headerlink" title="SOAP"></a>SOAP</h5><p>什么是 SOAP，我想不用多说，google 一把满眼都是。其实 SOAP 最早是针对 RPC 的一种解决方案，简单对象访问协议，很轻量，同时作为应用协议可以基于多种传输协议来传递消息（Http,SMTP 等）。但是随着 SOAP 作为 WebService 的广泛应用，不断地增加附加的内容，使得现在开发人员觉得 SOAP 很重，使用门槛很高。在 SOAP 后续的发展过程中，WS-* 一系列协议的制定，增加了 SOAP 的成熟度，也给 SOAP 增加了负担。</p><h5 id="REST"><a href="#REST" class="headerlink" title="REST"></a>REST</h5><p>REST 其实并不是什么协议也不是什么标准，而是将 Http 协议的设计初衷作了诠释，在 Http 协议被广泛利用的今天，越来越多的是将其作为传输协议，而非原先设计者所考虑的应用协议。SOAP 类型的 WebService 就是最好的例子，SOAP 消息完全就是将 Http 协议作为消息承载，以至于对于 Http 协议中的各种参数（例如编码，错误码等）都置之不顾。其实，最轻量级的应用协议就是 Http 协议。Http 协议所抽象的 get,post,put,delete 就好比数据库中最基本的增删改查，而互联网上的各种资源就好比数据库中的记录（可能这么比喻不是很好），对于各种资源的操作最后总是能抽象成为这四种基本操作，在定义了定位资源的规则以后，对于资源的操作通过标准的 Http 协议就可以实现，开发者也会受益于这种轻量级的协议。</p><h3 id="两者的特点"><a href="#两者的特点" class="headerlink" title="两者的特点"></a>两者的特点</h3><p><img src="\images\pasted-8.png" alt="upload successful"><br><img src="\images\pasted-9.png" alt="upload successful"></p><p><img src="\images\pasted-10.png" alt="upload successful"></p><h3 id="三-rest的使用"><a href="#三-rest的使用" class="headerlink" title="三.rest的使用"></a>三.rest的使用</h3><h4 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h4><p>我暂时了解到的使用就是定义路由时用对应的关键字对应相应的功能<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET /users - 获取 user 列表</span><br><span class="line">GET /users/12 - 获取指定 ID 为 12 的 user 对象</span><br><span class="line">POST /users - 创建一个新的 user</span><br><span class="line">PUT /users/12 - 更新 id 为 12 的 user</span><br><span class="line">PATCH /users/12 - 对 id 为 12 的 user 进行部分更新</span><br><span class="line">DELETE /users/12 - 删除 id 为 12 的 user</span><br></pre></td></tr></table></figure></p><p>这样更加语义化，看到路由就能大致猜到是什么功能，<br>然后由于rest是基于资源的所以提倡的是前端请求什么就返回什么，不去细分我现在只能意会暂时不知咋说，这种对于团队开发自然不好，但是对外人调用却只能这样，因为你并不知道他到底想要什么，所以对rest的使用应该看情况而定，不要太过死板。</p><h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><p>rest中异常应该抛出错误码让人们能比较快速的定位到错误的原因，错误码由自己确定，<br>但有一些常见的是约定俗成的，常见的如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">400（错误请求）服务器不理解请求的语法。</span><br><span class="line">401（未授权）请求要求身份验证。对于需要 token 的接口，服务器可能返回此响应。</span><br><span class="line">403（禁止）服务器拒绝请求。对于群组 / 聊天室服务，表示本次调用不符合群组 / 聊天室操作的正确逻辑，例如调用添加成员接口，添加已经在群组里的用户，或者移除聊天室中不存在的成员等操作。</span><br><span class="line">404（未找到）服务器找不到请求的接口。</span><br><span class="line">408（请求超时）服务器等候请求时发生超时。</span><br><span class="line">413（请求体过大）请求体超过了 5kb，拆成更小的请求体重试即可。</span><br><span class="line">415请求体的类型不支持。</span><br><span class="line">429（服务不可用）请求接口超过调用频率限制，即接口被限流。或超过社区版限制，如有需要可联系商务。</span><br><span class="line">500（服务器内部错误）服务器遇到错误，无法完成请求。</span><br><span class="line">501（尚未实施）服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码。</span><br><span class="line">502（错误网关）服务器作为网关或代理，从上游服务器收到无效响应。</span><br><span class="line">503（服务不可用）请求接口超过调用频率限制，即接口被限流。</span><br><span class="line">504（网关超时）服务器作为网关或代理，但是没有及时从上游服务器收到请求。</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;零-原因&quot;&gt;&lt;a href=&quot;#零-原因&quot; class=&quot;headerlink&quot; title=&quot;零.原因&quot;&gt;&lt;/a&gt;零.原因&lt;/h3&gt;&lt;p&gt;最近一直在学一个视频教程，视频中的老师介绍了一个rest原则，虽然感觉当时懂了，然后发现没多久就忘了，所以决定写这个来加深一
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>安装新版 xampp 后 apache 无法启动提示：Apache Service detected with wrong path 解决方案</title>
    <link href="http://yoursite.com/2018/05/25/3/"/>
    <id>http://yoursite.com/2018/05/25/3/</id>
    <published>2018-05-25T12:46:48.000Z</published>
    <updated>2018-05-25T12:54:41.815Z</updated>
    
    <content type="html"><![CDATA[<p>开始的时候xampp莫名其妙的报端口占用的错误，但是第一次重装软件就解决了<br>最近又遇到了这个错误重装软件后变成了这个错误<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Apache Service detected with wrong path.Change XAMPP Apache and Control Panel settings orUninstall/disable the other service manually first</span><br><span class="line">Found Path: &quot;H:\program files\xampp\apache\bin\httpd.exe&quot; -k runservice</span><br><span class="line">Expected Path: &quot;h:\xampp\apache\bin\httpd.exe&quot; -k runservice</span><br></pre></td></tr></table></figure></p><p>我从网上找到了两种解决方法</p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>还好没有出现端口被占用的情况，这是启动路径出现了错误，Found Path: “H:\program files\xampp\apache\bin\httpd.exe” -k runservice 这个是我以前老版本安装的路径，”h:\xampp\apache\bin\httpd.exe” -k runservice 这个才是我现在安装的路径，如何修改咧？</p><pre><code>首先，检查一下自己的环境变量的 path 中是否还残留以前自己添加的 xampp 路径，如果有就删掉，如果没有就进行下一步。然后就要进入自己的注册表：win+r 打开运行对话框 ---&gt; 输入 regedit 回车，进入注册表 ---&gt; 点击 HKEY_LOCAL_MACHINE----&gt;SYSTEM----&gt;currentControlSet----&gt;Services----&gt; 找到 Apache2.4，你就会在右边款到</code></pre><p>ImagePath 看看那个路径是不是以前那个版本的路径，如果是就选中 ImagePath 点击右键修改，把 xampp 里面提示的 Expected Path 后面的路径粘贴进去，然后确定。</p><pre><code>最后，重启 xampp 就可以了，启动 apache. 如果你的 mysql,filezilla 也出现路径问题，也可以按上面的方法修改。  偶然发现了第二种更加简便的方法，尝试之下有效</code></pre><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><pre><code>解决办法：Just uncheck and check button in Module Services column. It will automatically delete old service and start new service with new path. It happens when you delete xampp folder directly without stopping services.</code></pre><p>即点击 xampp 面板上 mysql 旁边的绿色勾勾，即可重新卸载旧的服务安装新的 mysql 服务。同时最好把 xampp 上的 mysql 配置文件和 xampp 配置文件里的 mysql 端口都改成 3307，以免和原来已经安装的 mysql 服务端口冲突。</p><p>若要重新启用原来安装的 mysql，管理员权限登录 cmd，D:\Program<br> Files\MySQL\MySQL Server 5.5\bin &gt; 下 mysqld.exe –install 就重新安装了服务了</p><p>ps: 修改原来机子的服务的名字可以完美解决 MySQL Service detected with wrong path 的问题，运行 mysqld.exe<br> –install –install MySQLhappy 可以得到名字为 MySQLhappy 的服务名，那样就不会有上述的冲突了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;开始的时候xampp莫名其妙的报端口占用的错误，但是第一次重装软件就解决了&lt;br&gt;最近又遇到了这个错误重装软件后变成了这个错误&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;sp
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>1对1，多对1，多对多总结</title>
    <link href="http://yoursite.com/2018/05/25/2/"/>
    <id>http://yoursite.com/2018/05/25/2/</id>
    <published>2018-05-25T06:48:59.000Z</published>
    <updated>2018-05-25T12:55:33.027Z</updated>
    
    <content type="html"><![CDATA[<p>thinkPHP5中的数据库的关系基本分为：一对一、多对一、多对多这三种</p><h3 id="一-引例"><a href="#一-引例" class="headerlink" title="一.引例"></a>一.引例</h3><p>1、一对一关系实例</p><ul><li>一个老师对应一个id，一个id对应一个老师  </li></ul><p>2、多对一关系实例   </p><ul><li>一个班级拥有多个学生，一个学生只能够属于某个班级 </li></ul><p>3、多对多实例</p><ul><li>一个学生可以选修多门课程，一个课程可以被多个学生选修</li></ul><h3 id="二-一对一"><a href="#二-一对一" class="headerlink" title="二.一对一"></a>二.一对一</h3><p>一对一的关系下，thinkPHP框架可以直接访问数据库中的数据，像下面一样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class TeacherController</span><br><span class="line">&#123;</span><br><span class="line">    public function index()</span><br><span class="line">    &#123;</span><br><span class="line">        $Teacher = new Teacher;</span><br><span class="line">        $teachers = $Teacher-&gt;select();</span><br><span class="line">        var_dump($teachers);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样可以直接输出teacher的所有信息</p><h3 id="三-多对一"><a href="#三-多对一" class="headerlink" title="三.多对一"></a>三.多对一</h3><p>多对一的关系</p><p><img src="\images\pasted-5.png" alt="upload successful"><br>如上图<br>在thinkPHP5中<br>多个学生对应于一个班级，这种情况下的访问法则为：<br>2、在这个方法中，通过一个id字段来获取这个对象；  </p><p>3、返回这个对象。<br>4，用该对象访问各种数据</p><p>以一个klass类为例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> public function Klass()</span><br><span class="line">&#123;</span><br><span class="line">   return $this-&gt;belongsTo(&apos;Klass&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="四-多对多"><a href="#四-多对多" class="headerlink" title="四.多对多"></a>四.多对多</h3><p>多对多的访问比较复杂，需要通过中间表来完成，像这样</p><p><img src="\images\pasted-6.png" alt="upload successful"><br>通过访问中间表来取得班级对应的课程<br>在thinkPHP5中可以自动对中间表进行操作，十分方便<br>但是thinkPHP中同样存在着bug<br>BUG1：<br>在Course中关联Klass，如果不加任何设置（直接将代码写为：return $this-&gt;belongsToMany(‘Klass’);），thinkphp 会尝试找course_klass这张表；而在Klass中关联Course，那么 thinkphp 则会尝试找klass_course这张表。显然，中间表只能有一个名字。这就使得我们在使用多对多关联时，还需要设置中间表的名字。</p><p>BUG2：<br>当我们传入表名时，thinkphp 没有自动为我们加入表前缀。这使得我们需要手动的进行配置，但显然我更希望默认是自动加入表前缀的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;thinkPHP5中的数据库的关系基本分为：一对一、多对一、多对多这三种&lt;/p&gt;
&lt;h3 id=&quot;一-引例&quot;&gt;&lt;a href=&quot;#一-引例&quot; class=&quot;headerlink&quot; title=&quot;一.引例&quot;&gt;&lt;/a&gt;一.引例&lt;/h3&gt;&lt;p&gt;1、一对一关系实例&lt;/p&gt;
&lt;ul&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>记录一次安装xdebug</title>
    <link href="http://yoursite.com/2018/05/19/1/"/>
    <id>http://yoursite.com/2018/05/19/1/</id>
    <published>2018-05-19T06:55:00.000Z</published>
    <updated>2018-05-19T08:32:38.789Z</updated>
    
    <content type="html"><![CDATA[<h3 id="起因："><a href="#起因：" class="headerlink" title="起因："></a>起因：</h3><p>为了更简单的分析错误，于是打算装一个xdebug的插件，于是从网上找了一个教程就开始装。</p><h3 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h3><p>首先来到<a href="https://xdebug.org/wizard.php" target="_blank" rel="noopener">这个网站</a><br>在空白框里输入了输入了phpinfo得到的相关信息：<br><img src="\images\pasted-0.png" alt="网站图片"><br>(由于PHP5那个xampp不知为何无法启动所以用php7这张代替)<br><img src="\images\1.png" alt="提示信息"><br>可见得到的信息中并没有教程和学长所说的推荐版本和安装步骤<br>开始也没仔细看下面的提示所以以为是按照版本号去这里面找<br><img src="\images\pasted-1.png" alt="upload successful"><br>经过多次尝试，仍未成功，然后决定找学长帮忙</p><p>再次进入那个网站输入信息后发现下面有提示：php7.0以下的已经不给版本和步骤了<br>（xampp无法启动，所以此处不配图）</p><p>经过多次尝试无果，所以决定讲php升级的7</p><p><img src="\images\pasted-2.png" alt="upload successful"></p><p>按照提示顺利安装</p><p><img src="\images\pasted-3.png" alt="upload successful">  </p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p> 在接触新的东西时，要注意观察，不要忽略了重要的信息，同时也应该尽快让自己改掉不喜欢看英文提示的坏毛病，总觉得英文麻烦，实际上大部分的英文还是比较简单的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;起因：&quot;&gt;&lt;a href=&quot;#起因：&quot; class=&quot;headerlink&quot; title=&quot;起因：&quot;&gt;&lt;/a&gt;起因：&lt;/h3&gt;&lt;p&gt;为了更简单的分析错误，于是打算装一个xdebug的插件，于是从网上找了一个教程就开始装。&lt;/p&gt;
&lt;h3 id=&quot;安装过程&quot;&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2018/05/19/hello-world/"/>
    <id>http://yoursite.com/2018/05/19/hello-world/</id>
    <published>2018-05-19T03:22:00.000Z</published>
    <updated>2018-06-12T14:37:41.009Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check     <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check     &lt;a href=&quot;https://h
      
    
    </summary>
    
    
  </entry>
  
</feed>
